#!/usr/bin/env bash
# NOTE: Port-reuse detection and token loading are now built into the native
# binaries (`am start` / `mcp-agent-mail serve`). This wrapper remains for
# development convenience (release binary fallback + local default flags).
set -euo pipefail

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
repo_root="$(cd "${script_dir}/.." && pwd)"

usage() {
  cat <<'EOF'
Usage: am [serve|start] [options] [-- <extra args for `mcp-agent-mail serve`>]

Compatibility/dev convenience runner for local MCP Agent Mail development.
Defaults:
- MCP transport path (`/mcp/`)
- LOG_RICH_ENABLED=true
- host=127.0.0.1, port=8765

Native-first note:
- `am` / `am start` is the canonical operator entrypoint.
- Native startup already handles port-reuse detection and HTTP_BEARER_TOKEN
  discovery from ~/.mcp_agent_mail/.env (fallback: ~/mcp_agent_mail/.env).
- This script is optional compatibility glue for local dev workflows.
- On startup, this wrapper auto-syncs the MCP URL for known agent harness
  configs (Codex/Claude/common MCP JSON layouts). Set
  `AM_SYNC_AGENT_CONFIGS=0` to disable. Add extra config files with
  `AM_SYNC_CONFIG_PATHS=/path/one:/path/two`. Set
  `AM_SYNC_DISCOVER_CONFIGS=1` to enable opt-in discovery of additional
  config-like files under ~/.config, ~/.codex, ~/.claude, ~/.cursor.

Options:
  --host <host>          Server host (default: 127.0.0.1)
  --port <port>          Server port (default: 8765)
  --path <mcp|api|/x/>   Base path (default: mcp)
  --mcp                  Shortcut for --path mcp
  --api                  Shortcut for --path api
  --env-file <path>      Env file for HTTP_BEARER_TOKEN (default: ~/.mcp_agent_mail/.env, fallback: ~/mcp_agent_mail/.env)
  --no-auth              Unset HTTP_BEARER_TOKEN for this run
  --no-tui               Disable interactive TUI (headless mode)
  -h, --help             Show help

Examples:
  scripts/am
  scripts/am serve
  am
  am start
  scripts/am --path api
  scripts/am --api
  scripts/am --host 0.0.0.0 --port 9000
EOF
}

normalize_http_path() {
  local value="$1"
  case "$value" in
    mcp|/mcp|/mcp/) echo "/mcp/" ;;
    api|/api|/api/) echo "/api/" ;;
    *)
      if [[ "$value" != /* ]]; then
        value="/$value"
      fi
      if [[ "$value" != */ ]]; then
        value="$value/"
      fi
      echo "$value"
      ;;
  esac
}

sync_toml_mcp_url() {
  local config_file="$1"
  local desired_url="$2"
  local create_if_missing="${3:-0}"
  local tmp_file="${config_file}.am-sync.$$"

  if [[ ! -f "$config_file" ]]; then
    return 0
  fi

  awk -v desired_url="$desired_url" -v create_if_missing="$create_if_missing" '
    BEGIN {
      in_section = 0
      saw_section = 0
      saw_url_in_section = 0
    }

    /^\[mcp_servers\.mcp_agent_mail\][[:space:]]*$/ || /^\[mcp_servers\."mcp-agent-mail"\][[:space:]]*$/ {
      if (in_section && !saw_url_in_section) {
        print "url = \"" desired_url "\""
      }
      in_section = 1
      saw_section = 1
      saw_url_in_section = 0
      print
      next
    }

    /^\[/ {
      if (in_section && !saw_url_in_section) {
        print "url = \"" desired_url "\""
      }
      in_section = 0
    }

    {
      if (in_section && $0 ~ /^[[:space:]]*url[[:space:]]*=/) {
        print "url = \"" desired_url "\""
        saw_url_in_section = 1
        next
      }
      print
    }

    END {
      if (in_section && !saw_url_in_section) {
        print "url = \"" desired_url "\""
      }
      if (!saw_section && create_if_missing == 1) {
        print ""
        print "[mcp_servers.mcp_agent_mail]"
        print "url = \"" desired_url "\""
      }
    }
  ' "$config_file" > "$tmp_file"

  if cmp -s "$config_file" "$tmp_file"; then
    rm -f "$tmp_file"
    return 0
  fi

  chmod --reference="$config_file" "$tmp_file" 2>/dev/null || true
  mv "$tmp_file" "$config_file"
  echo "am: synced MCP URL to ${desired_url} (${config_file})." >&2
}

sync_json_mcp_url() {
  local config_file="$1"
  local desired_url="$2"
  local tmp_file="${config_file}.am-sync.$$"

  if [[ ! -f "$config_file" ]]; then
    return 0
  fi

  if ! command -v jq >/dev/null 2>&1; then
    return 0
  fi

  # Only touch files that actually contain a known mcp-agent-mail server entry.
  if ! jq -e '
    (.mcpServers?["mcp-agent-mail"]? != null) or
    (.mcpServers?["mcp_agent_mail"]? != null) or
    (.mcp?["mcp-agent-mail"]? != null) or
    (.mcp?["mcp_agent_mail"]? != null) or
    (.servers?["mcp-agent-mail"]? != null) or
    (.servers?["mcp_agent_mail"]? != null) or
    (.mcp_servers?["mcp_agent_mail"]? != null) or
    (.mcp_servers?["mcp-agent-mail"]? != null)
  ' "$config_file" >/dev/null 2>&1; then
    return 0
  fi

  if ! jq --arg url "$desired_url" '
    if (.mcpServers?["mcp-agent-mail"]? != null) then
      .mcpServers["mcp-agent-mail"].url = $url
    elif (.mcpServers?["mcp_agent_mail"]? != null) then
      .mcpServers["mcp_agent_mail"].url = $url
    elif (.mcp?["mcp-agent-mail"]? != null) then
      .mcp["mcp-agent-mail"].url = $url
    elif (.mcp?["mcp_agent_mail"]? != null) then
      .mcp["mcp_agent_mail"].url = $url
    elif (.servers?["mcp-agent-mail"]? != null) then
      .servers["mcp-agent-mail"].url = $url
    elif (.servers?["mcp_agent_mail"]? != null) then
      .servers["mcp_agent_mail"].url = $url
    elif (.mcp_servers?["mcp_agent_mail"]? != null) then
      .mcp_servers["mcp_agent_mail"].url = $url
    elif (.mcp_servers?["mcp-agent-mail"]? != null) then
      .mcp_servers["mcp-agent-mail"].url = $url
    else
      .
    end
  ' "$config_file" > "$tmp_file"; then
    rm -f "$tmp_file"
    return 0
  fi

  if cmp -s "$config_file" "$tmp_file"; then
    rm -f "$tmp_file"
    return 0
  fi

  chmod --reference="$config_file" "$tmp_file" 2>/dev/null || true
  mv "$tmp_file" "$config_file"
  echo "am: synced MCP URL to ${desired_url} (${config_file})." >&2
}

mcp_sync_client_host() {
  local host="$1"
  case "$host" in
    0.0.0.0|::|"[::]") echo "127.0.0.1" ;;
    *:*)
      if [[ "$host" == \[*\] ]]; then
        echo "$host"
      else
        echo "[$host]"
      fi
      ;;
    *) echo "$host" ;;
  esac
}

sync_path_mcp_url() {
  local config_file="$1"
  local desired_url="$2"
  local create_if_missing="${3:-0}"

  if [[ ! -f "$config_file" ]]; then
    return 0
  fi

  case "$config_file" in
    *.toml) sync_toml_mcp_url "$config_file" "$desired_url" "$create_if_missing" ;;
    *.json) sync_json_mcp_url "$config_file" "$desired_url" ;;
    *) return 0 ;;
  esac
}

find_listener_pids() {
  local port="$1"
  local ss_output=""

  if command -v lsof >/dev/null 2>&1; then
    lsof -tiTCP:"${port}" -sTCP:LISTEN 2>/dev/null | awk '!seen[$0]++'
    return 0
  fi

  if ! command -v ss >/dev/null 2>&1; then
    return 0
  fi

  ss_output="$(ss -ltnp 2>/dev/null || true)"
  if [[ -z "$ss_output" ]]; then
    return 0
  fi

  awk -v p=":${port}" '
    BEGIN {
      matched_without_pid = 0
      printed_any = 0
    }
    $4 ~ p"$" || $4 ~ "\\]:" substr(p,2) "$" {
      s = $0
      line_had_pid = 0
      while (match(s, /pid=[0-9]+/)) {
        v = substr(s, RSTART + 4, RLENGTH - 4)
        if (!seen[v]++) {
          print v
          printed_any = 1
        }
        line_had_pid = 1
        s = substr(s, RSTART + RLENGTH)
      }
      if (!line_had_pid) {
        matched_without_pid = 1
      }
    }
    END {
      if (matched_without_pid && !printed_any) {
        print "UNKNOWN"
      }
    }
  ' <<< "$ss_output"
}

extract_http_path_from_listener_cmd() {
  local cmd="$1"
  local raw_path=""

  if [[ "$cmd" =~ --path=([^[:space:]]+) ]]; then
    raw_path="${BASH_REMATCH[1]}"
  elif [[ "$cmd" =~ --path[[:space:]]+([^[:space:]]+) ]]; then
    raw_path="${BASH_REMATCH[1]}"
  fi

  if [[ -z "$raw_path" ]]; then
    echo "/mcp/"
  else
    normalize_http_path "$raw_path"
  fi
}

extract_http_host_from_listener_cmd() {
  local cmd="$1"
  local raw_host=""

  if [[ "$cmd" =~ --host=([^[:space:]]+) ]]; then
    raw_host="${BASH_REMATCH[1]}"
  elif [[ "$cmd" =~ --host[[:space:]]+([^[:space:]]+) ]]; then
    raw_host="${BASH_REMATCH[1]}"
  fi

  if [[ -z "$raw_host" ]]; then
    echo "127.0.0.1"
  else
    echo "$raw_host"
  fi
}

sync_agent_harness_mcp_url() {
  local host="$1"
  local port="$2"
  local path="$3"
  local sync_host
  local desired_url
  local config_file
  local -a default_candidates=(
    "${CODEX_CONFIG_FILE:-${HOME}/.codex/config.toml}"
    "${CLAUDE_SETTINGS_FILE:-${HOME}/.claude/settings.json}"
    "${CLAUDE_DESKTOP_CONFIG_FILE:-${HOME}/.claude/claude_desktop_config.json}"
    "${HOME}/.config/Claude/claude_desktop_config.json"
    "${HOME}/.cursor/mcp.json"
    "${HOME}/.cursor/mcp_config.json"
  )

  # Opt-out for edge cases; default is self-healing MCP URL sync for harnesses.
  if [[ "${AM_SYNC_AGENT_CONFIGS:-1}" != "1" ]]; then
    return 0
  fi

  sync_host="$(mcp_sync_client_host "$host")"
  desired_url="http://${sync_host}:${port}${path}"

  # Known defaults.
  sync_path_mcp_url "${default_candidates[0]}" "$desired_url" 1
  sync_path_mcp_url "${default_candidates[1]}" "$desired_url" 0
  sync_path_mcp_url "${default_candidates[2]}" "$desired_url" 0
  sync_path_mcp_url "${default_candidates[3]}" "$desired_url" 0
  sync_path_mcp_url "${default_candidates[4]}" "$desired_url" 0
  sync_path_mcp_url "${default_candidates[5]}" "$desired_url" 0

  # Optional discovery for additional harness configs (opt-in).
  if [[ "${AM_SYNC_DISCOVER_CONFIGS:-0}" == "1" ]] && command -v rg >/dev/null 2>&1; then
    while IFS= read -r config_file; do
      case "$config_file" in
        "${default_candidates[0]}"|"${default_candidates[1]}"|"${default_candidates[2]}"|"${default_candidates[3]}"|"${default_candidates[4]}"|"${default_candidates[5]}")
          continue
          ;;
      esac
      sync_path_mcp_url "$config_file" "$desired_url" 0
    done < <(
      rg -l --max-count 1 \
        -g 'settings.json' -g '*config*.json' -g '*mcp*.json' -g '*.toml' \
        -g '!**/tasks/**' -g '!**/todos/**' -g '!**/projects/**' -g '!**/telemetry/**' \
        '(mcp-agent-mail|mcp_agent_mail)' \
        "${HOME}/.config" "${HOME}/.codex" "${HOME}/.claude" "${HOME}/.cursor" 2>/dev/null || true
    )
  fi

  # Optional: add more harness configs with a colon-delimited list.
  # Example: AM_SYNC_CONFIG_PATHS="$HOME/.aider/config.json:$HOME/.foo/mcp.toml"
  if [[ -n "${AM_SYNC_CONFIG_PATHS:-}" ]]; then
    local -a extra_candidates=()
    IFS=':' read -r -a extra_candidates <<< "${AM_SYNC_CONFIG_PATHS}"
    for config_file in "${extra_candidates[@]}"; do
      sync_path_mcp_url "$config_file" "$desired_url"
    done
  fi
}

read_env_value() {
  local file="$1"
  local key="$2"
  if [[ ! -f "$file" ]]; then
    return 1
  fi
  command grep -E "^[[:space:]]*${key}=" "$file" | tail -n1 | cut -d= -f2-
}

default_env_file() {
  local preferred="${HOME}/.mcp_agent_mail/.env"
  local legacy="${HOME}/mcp_agent_mail/.env"
  if [[ -f "$preferred" ]]; then
    echo "$preferred"
  elif [[ -f "$legacy" ]]; then
    echo "$legacy"
  else
    echo "$preferred"
  fi
}

if [[ $# -gt 0 ]]; then
  case "$1" in
    serve|start) shift ;;
    help|-h|--help)
      usage
      exit 0
      ;;
    -*)
      # Server mode flags (`--host`, `--port`, etc.) continue through option parsing.
      ;;
    *)
      # Any non-option token is treated as a CLI subcommand passthrough.
      cd "$repo_root"
      binary="${CARGO_TARGET_DIR:-${repo_root}/target}/release/mcp-agent-mail"
      if [[ -x "$binary" ]]; then
        exec env AM_INTERFACE_MODE=cli "$binary" "$@"
      else
        exec env AM_INTERFACE_MODE=cli cargo run --release -p mcp-agent-mail -- "$@"
      fi
      ;;
  esac
fi

host="127.0.0.1"
port="8765"
path_mode="mcp"
env_file="$(default_env_file)"
no_auth=0
no_tui=0
extra_args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --host)
      host="${2:-}"
      shift 2
      ;;
    --port)
      port="${2:-}"
      shift 2
      ;;
    --path)
      path_mode="${2:-}"
      shift 2
      ;;
    --mcp)
      path_mode="mcp"
      shift
      ;;
    --api)
      path_mode="api"
      shift
      ;;
    --env-file)
      env_file="${2:-}"
      shift 2
      ;;
    --no-auth)
      no_auth=1
      shift
      ;;
    --no-tui)
      no_tui=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      extra_args=("$@")
      break
      ;;
    *)
      echo "Unknown option: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
done

resolved_path="$(normalize_http_path "$path_mode")"
export LOG_RICH_ENABLED="${LOG_RICH_ENABLED:-true}"

# Reuse an already-running Agent Mail server on the same host/port to avoid
# clobbering a healthy instance started by another tool/agent.
if [[ "${AM_REUSE_RUNNING:-1}" == "1" ]]; then
  listener_pid=""
  listener_cmd=""
  non_agent_pid=""
  listener_found=0
  listener_is_agent=0
  listener_candidate=""
  listener_candidates=()
  listener_host="$host"
  listener_path="$resolved_path"
  mapfile -t listener_candidates < <(find_listener_pids "$port")
  for listener_candidate in "${listener_candidates[@]}"; do
    [[ -z "$listener_candidate" ]] && continue
    listener_found=1
    listener_cmd="$(ps -p "$listener_candidate" -o args= 2>/dev/null || true)"
    if [[ "$listener_cmd" == *"mcp_agent_mail"* ]] || [[ "$listener_cmd" == *"mcp-agent-mail"* ]]; then
      listener_is_agent=1
      listener_pid="$listener_candidate"
      break
    fi
    if [[ -z "$non_agent_pid" ]]; then
      non_agent_pid="$listener_candidate"
    fi
  done

  if [[ "$listener_is_agent" -eq 1 ]]; then
    listener_host="$(extract_http_host_from_listener_cmd "$listener_cmd")"
    listener_path="$(extract_http_path_from_listener_cmd "$listener_cmd")"
    if [[ "$listener_host" != "$host" ]]; then
      echo "am: requested host ${host} differs from running server host ${listener_host}; reusing running server host." >&2
    fi
    if [[ "$listener_path" != "$resolved_path" ]]; then
      echo "am: requested path ${resolved_path} differs from running server path ${listener_path}; reusing running server path." >&2
    fi
    sync_agent_harness_mcp_url "$listener_host" "$port" "$listener_path"
    echo "am: reusing existing Agent Mail server on ${listener_host}:${port} (pid ${listener_pid})." >&2
    exit 0
  fi

  if [[ "$listener_found" -eq 1 ]]; then
    if [[ -n "$non_agent_pid" ]] && [[ "$non_agent_pid" != "UNKNOWN" ]]; then
      echo "am: port ${port} is in use by a non-Agent-Mail process (pid ${non_agent_pid})." >&2
    else
      echo "am: port ${port} appears in use by a non-Agent-Mail process." >&2
    fi
    echo "am: free the port or choose a different one with --port." >&2
    exit 2
  fi
fi

if [[ "$no_auth" -eq 1 ]]; then
  unset HTTP_BEARER_TOKEN
else
  if [[ -z "${HTTP_BEARER_TOKEN:-}" ]]; then
    if token="$(read_env_value "$env_file" "HTTP_BEARER_TOKEN" 2>/dev/null)"; then
      token="$(printf '%s' "$token" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
      token="$(printf '%s' "$token" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")"
      if [[ -n "$token" ]]; then
        export HTTP_BEARER_TOKEN="$token"
      fi
    fi
  fi
fi

tui_flag=()
if [[ "$no_tui" -eq 1 ]]; then
  tui_flag=(--no-tui)
fi

# Sync harness MCP URLs only after we know the requested port is viable.
sync_agent_harness_mcp_url "$host" "$port" "$resolved_path"

cd "$repo_root"
echo "am: host=${host} port=${port} path=${resolved_path} tui=$([[ "$no_tui" -eq 0 ]] && echo on || echo off) rich=${LOG_RICH_ENABLED}" >&2

# Use release binary if available, fall back to cargo run
binary="${CARGO_TARGET_DIR:-${repo_root}/target}/release/mcp-agent-mail"
if [[ -x "$binary" ]]; then
  exec "$binary" serve --host "$host" --port "$port" --path "$resolved_path" "${tui_flag[@]}" "${extra_args[@]}"
else
  exec cargo run --release -p mcp-agent-mail -- serve --host "$host" --port "$port" --path "$resolved_path" "${tui_flag[@]}" "${extra_args[@]}"
fi
